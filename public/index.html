<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discord Voice Stats</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #2c2f33;
            color: #ffffff;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            color: #7289da;
            margin-bottom: 10px;
        }
        .header p {
            color: #99aab5;
            font-size: 14px;
        }
        .controls {
            display: flex;
            align-items: center;
            gap: 15px;
            background-color: #36393f;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-group label {
            font-weight: bold;
            color: #dcddde;
        }
        select, input {
            background-color: #40444b;
            border: 1px solid #4f545c;
            padding: 8px 12px;
            color: #ffffff;
            border-radius: 4px;
            font-size: 14px;
        }
        select:focus, input:focus {
            outline: none;
            border-color: #7289da;
        }
        button {
            background-color: #7289da;
            border: none;
            padding: 10px 20px;
            color: #ffffff;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #677bc4;
        }
        button:disabled {
            background-color: #4f545c;
            cursor: not-allowed;
        }
        .channels-container {
            background-color: #36393f;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .channels-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .channels-header h2 {
            margin: 0;
            color: #ffffff;
        }
        .channels-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
        }
        .channel-card {
            background-color: #2f3136;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #40444b;
            transition: border-color 0.2s;
        }
        .channel-card:hover {
            border-color: #7289da;
        }
        .channel-card.selected {
            border-color: #43b581;
            background-color: #2f3136;
        }
        .channel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .channel-name {
            font-weight: bold;
            color: #ffffff;
        }
        .member-count {
            background-color: #43b581;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: bold;
        }
        .channel-info {
            font-size: 12px;
            color: #99aab5;
        }
        .chart-container {
            background-color: #36393f;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            height: 400px;
        }
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .chart-header h2 {
            margin: 0;
            color: #ffffff;
        }
        .stats-container {
            background-color: #36393f;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .stats-header h2 {
            margin: 0 0 15px 0;
            color: #ffffff;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background-color: #2f3136;
            border-radius: 6px;
            overflow: hidden;
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #40444b;
        }
        th {
            background-color: #40444b;
            color: #ffffff;
            font-weight: bold;
        }
        td {
            color: #dcddde;
        }
        tr:hover {
            background-color: #36393f;
        }
        .loading {
            text-align: center;
            color: #99aab5;
            padding: 20px;
        }
        .error {
            background-color: #f04747;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .success {
            background-color: #43b581;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🎤 Discord Voice Stats</h1>
        <p>Suivi en temps réel de l'activité vocale</p>
    </div>

    <div class="controls">
        <div class="control-group">
            <label for="guildSelect">Serveur:</label>
            <select id="guildSelect" onchange="updateChannels()">
                <option value="">Sélectionner un serveur</option>
            </select>
        </div>
        <div class="control-group">
            <label for="timeRange">Période:</label>
            <select id="timeRange">
                <option value="1">Dernière heure</option>
                <option value="6">6 heures</option>
                <option value="24">24 heures</option>
                <option value="168">7 jours</option>
            </select>
        </div>
        <button onclick="loadSelectedChannels()" id="loadButton" disabled>
            📊 Charger les statistiques
        </button>
    </div>

    <div class="channels-container">
        <div class="channels-header">
            <h2>📺 Canaux vocaux</h2>
            <button onclick="selectAllChannels()" style="padding: 5px 10px; font-size: 12px;">
                Tout sélectionner
            </button>
        </div>
        <div id="channelsList" class="channels-grid">
            <div class="loading">Sélectionnez un serveur pour voir les canaux</div>
        </div>
    </div>

    <div class="chart-container">
        <div class="chart-header">
            <h2>📈 Évolution de l'activité</h2>
        </div>
        <div class="chart-controls" style="display: flex; gap: 16px; align-items: center; margin-bottom: 16px;">
            <label>Intervalle
                <select id="intervalSelect">
                    <option value="1m">Minute</option>
                    <option value="1h">Heure</option>
                    <option value="1d">Jour</option>
                </select>
            </label>
            <label>Début
                <input type="datetime-local" id="startInput">
            </label>
            <label>Fin
                <input type="datetime-local" id="endInput">
            </label>
            <button id="loadButton" onclick="loadSelectedChannels()">📊 Charger les statistiques</button>
        </div>
        <div style="height: 320px; position: relative;">
            <canvas id="activityChart"></canvas>
        </div>
    </div>

    <div class="stats-container">
        <div class="stats-header">
            <h2>📋 Statistiques détaillées</h2>
        </div>
        <table>
            <thead>
                <tr>
                    <th>Canal</th>
                    <th>Membres actuels</th>
                    <th>Moyenne</th>
                    <th>Maximum</th>
                    <th>Dernière activité</th>
                </tr>
            </thead>
            <tbody id="statsBody">
            </tbody>
        </table>
    </div>

    <script>
        let guildsData = {};
        let activityChart = null;

        // Charger la liste des serveurs
        async function loadGuilds() {
            try {
                const response = await fetch('/api/voice/guilds');
                const guilds = await response.json();
                
                const guildSelect = document.getElementById('guildSelect');
                guildSelect.innerHTML = '<option value="">Sélectionner un serveur</option>';
                
                guildsData = {};
                
                guilds.forEach(guild => {
                    guildsData[guild._id] = guild.channels;
                    const option = document.createElement('option');
                    option.value = guild._id;
                    option.textContent = `Serveur ${guild._id}`;
                    guildSelect.appendChild(option);
                });
                
                console.log('Serveurs chargés:', guilds);
            } catch (error) {
                console.error('Erreur lors du chargement des serveurs:', error);
                showError('Erreur lors du chargement des serveurs');
            }
        }

        // Mettre à jour la liste des canaux
        function updateChannels() {
            const guildId = document.getElementById('guildSelect').value;
            const channelsList = document.getElementById('channelsList');
            const loadButton = document.getElementById('loadButton');
            
            channelsList.innerHTML = '';
            loadButton.disabled = true;

            if (!guildId || !guildsData[guildId]) {
                channelsList.innerHTML = '<div class="loading">Aucun canal trouvé</div>';
                return;
            }

            const channels = guildsData[guildId];
            if (channels.length === 0) {
                channelsList.innerHTML = '<div class="loading">Aucun canal vocal actif</div>';
                return;
            }

            channels.forEach(channel => {
                const card = document.createElement('div');
                card.className = 'channel-card';
                card.onclick = () => toggleChannelSelection(card, channel.channelId);
                
                const memberCount = channel.members ? channel.members.length : 0;
                const lastActivity = new Date(channel.lastActivity).toLocaleString();
                
                card.innerHTML = `
                    <div class="channel-header">
                        <div class="channel-name">${channel.name || `Canal ${channel.channelId}`}</div>
                        <div class="member-count">${memberCount} membre${memberCount > 1 ? 's' : ''}</div>
                    </div>
                    <div class="channel-info">
                        ID: ${channel.channelId}<br>
                        Dernière activité: ${lastActivity}
                    </div>
                `;
                channelsList.appendChild(card);
            });

            loadButton.disabled = false;
        }

        // Basculer la sélection d'un canal
        function toggleChannelSelection(card, channelId) {
            card.classList.toggle('selected');
            const checkbox = card.querySelector('input[type="checkbox"]');
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
            }
        }

        // Sélectionner tous les canaux
        function selectAllChannels() {
            const cards = document.querySelectorAll('.channel-card');
            cards.forEach(card => {
                card.classList.add('selected');
            });
        }

        // Charger les statistiques des canaux sélectionnés
        async function loadSelectedChannels() {
            const guildId = document.getElementById('guildSelect').value;
            const interval = document.getElementById('intervalSelect').value;
            const startInput = document.getElementById('startInput').value;
            const endInput = document.getElementById('endInput').value;
            const allChannels = guildsData[guildId] || [];

            if (!guildId || allChannels.length === 0) {
                showError('Aucun canal trouvé pour cette guilde');
                return;
            }

            const loadButton = document.getElementById('loadButton');
            loadButton.disabled = true;
            loadButton.textContent = '⏳ Chargement...';

            try {
                // Gestion des dates
                let start, end;
                if (startInput && endInput) {
                    start = new Date(startInput);
                    end = new Date(endInput);
                } else {
                    // Valeur par défaut : 6 dernières heures
                    end = new Date();
                    start = new Date(end - 6 * 60 * 60 * 1000);
                }

                // Récupérer tous les documents de la guilde sur la période
                const url = `/api/voice/${guildId}?start=${start.toISOString()}&end=${end.toISOString()}`;
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Erreur HTTP ${response.status} pour la guilde ${guildId}`);
                }
                const guildRecords = await response.json();

                // Fonction de reconstruction minute par minute
                function reconstructMinuteByMinute(guildRecords, start, end) {
                    // 1. Générer la liste des minutes entre start et end
                    const minutes = [];
                    let current = new Date(start);
                    while (current <= end) {
                        minutes.push(new Date(current));
                        current = new Date(current.getTime() + 60 * 1000);
                    }

                    // 2. Indexer les records par sessionStart
                    guildRecords.sort((a, b) => new Date(a.sessionStart) - new Date(b.sessionStart));

                    // 3. Trouver tous les salons connus
                    const allChannelIds = new Set();
                    const channelNames = {};
                    guildRecords.forEach(doc => doc.channels.forEach(ch => {
                        allChannelIds.add(ch.channelId);
                        if (ch.channelName) channelNames[ch.channelId] = ch.channelName;
                    }));

                    // 4. Pour chaque minute, pour chaque salon, propager la dernière composition connue
                    const lastState = {}; // channelId -> members[]
                    const series = {};    // channelId -> [{ timestamp, memberCount }]

                    for (const channelId of allChannelIds) {
                        series[channelId] = [];
                        lastState[channelId] = [];
                    }

                    let docIndex = 0;
                    for (const minute of minutes) {
                        // Avancer dans les docs si besoin
                        while (
                            docIndex < guildRecords.length &&
                            new Date(guildRecords[docIndex].sessionStart) <= minute
                        ) {
                            const doc = guildRecords[docIndex];
                            for (const ch of doc.channels) {
                                lastState[ch.channelId] = ch.members || [];
                            }
                            docIndex++;
                        }
                        // Pour chaque salon, enregistrer le memberCount à cette minute
                        for (const channelId of allChannelIds) {
                            series[channelId].push({
                                timestamp: new Date(minute),
                                memberCount: lastState[channelId].length
                            });
                        }
                    }
                    return { series, channelNames };
                }

                // Appliquer la reconstruction
                const { series, channelNames } = reconstructMinuteByMinute(guildRecords, start, end);

                // Préparer les données pour le graphique
                const chartData = Array.from(Object.entries(series)).map(([channelId, data]) => ({
                    channelId,
                    channelName: channelNames[channelId] || `Canal ${channelId}`,
                    timestamps: data.map(d => d.timestamp),
                    memberCounts: data.map(d => d.memberCount)
                }));

                createChart(chartData);
                // Pour le tableau, on peut afficher la dernière valeur de chaque série
                const activities = chartData.map(({ channelId, channelName, timestamps, memberCounts }) => ({
                    channelId,
                    channelName,
                    data: timestamps.map((timestamp, i) => ({
                        timestamp,
                        memberCount: memberCounts[i]
                    }))
                }));
                updateStatsTable(activities);
                showSuccess(`${chartData.length} canal${chartData.length > 1 ? 'x' : ''} chargé${chartData.length > 1 ? 's' : ''}`);
            } catch (error) {
                console.error('Erreur lors du chargement des stats:', error);
                showError('Erreur lors du chargement des statistiques: ' + error.message);
            } finally {
                loadButton.disabled = false;
                loadButton.textContent = '📊 Charger les statistiques';
            }
        }

        // Créer le graphique
        function createChart(channelsData) {
            const ctx = document.getElementById('activityChart').getContext('2d');
            
            if (activityChart) {
                activityChart.destroy();
            }

            const colors = [
                '#7289da', '#43b581', '#faa61a', '#f04747', 
                '#747f8d', '#9b59b6', '#e74c3c', '#3498db'
            ];

            // Créer les datasets avec les données temporelles
            const datasets = channelsData.map((channel, index) => ({
                label: channel.channelName,
                data: channel.timestamps.map((timestamp, i) => ({
                    x: timestamp,
                    y: channel.memberCounts[i]
                })),
                borderColor: colors[index % colors.length],
                backgroundColor: colors[index % colors.length] + '20',
                tension: 0, // pas d'interpolation
                stepped: true, // courbe en escalier
                fill: false,
                pointRadius: 2,
                pointHoverRadius: 4
            }));

            activityChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 0
                    },
                    layout: {
                        padding: {
                            top: 10,
                            bottom: 10
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#ffffff',
                                usePointStyle: true
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(context) {
                                    const date = new Date(context[0].parsed.x);
                                    return date.toLocaleString('fr-FR', {
                                        day: '2-digit',
                                        month: '2-digit',
                                        hour: '2-digit',
                                        minute: '2-digit'
                                    });
                                },
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y} membre${context.parsed.y > 1 ? 's' : ''}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'hour',
                                displayFormats: {
                                    hour: 'HH:mm'
                                }
                            },
                            ticks: {
                                color: '#ffffff',
                                maxTicksLimit: 8
                            },
                            grid: {
                                color: '#40444b'
                            },
                            title: {
                                display: true,
                                text: 'Temps',
                                color: '#ffffff'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: '#ffffff',
                                stepSize: 1,
                                maxTicksLimit: 10,
                                callback: function(value) {
                                    return value + ' membre' + (value > 1 ? 's' : '');
                                }
                            },
                            grid: {
                                color: '#40444b'
                            },
                            title: {
                                display: true,
                                text: 'Nombre de membres',
                                color: '#ffffff'
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    elements: {
                        point: {
                            radius: 2,
                            hoverRadius: 4
                        },
                        line: {
                            tension: 0.2
                        }
                    }
                }
            });
        }

        // Mettre à jour le tableau des statistiques
        function updateStatsTable(channelsData) {
            const statsBody = document.getElementById('statsBody');
            statsBody.innerHTML = '';
            
            channelsData.forEach(({ channelId, channelName, data }) => {
                if (data.length > 0) {
                    const lastActivity = data[data.length - 1];
                    const avgMembers = data.reduce((sum, d) => sum + d.memberCount, 0) / data.length;
                    const maxMembers = Math.max(...data.map(d => d.memberCount));
                    
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td><strong>${channelName}</strong></td>
                        <td><span class="member-count">${lastActivity.memberCount}</span></td>
                        <td>${avgMembers.toFixed(1)}</td>
                        <td>${maxMembers}</td>
                        <td>${new Date(lastActivity.timestamp).toLocaleString('fr-FR')}</td>
                    `;
                    statsBody.appendChild(row);
                }
            });
        }

        // Afficher un message d'erreur
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.body.insertBefore(errorDiv, document.body.firstChild);
            setTimeout(() => errorDiv.remove(), 5000);
        }

        // Afficher un message de succès
        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = message;
            document.body.insertBefore(successDiv, document.body.firstChild);
            setTimeout(() => successDiv.remove(), 3000);
        }

        // Charger les serveurs au démarrage
        window.onload = loadGuilds;

        // Ajoute un script pour initialiser les valeurs par défaut
        window.addEventListener('DOMContentLoaded', () => {
        const now = new Date();
        // Début de la journée (00:00)
        const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
        // Fin de la journée (23:59)
        const endOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 0, 0);
        document.getElementById('startInput').value = startOfDay.toISOString().slice(0,16);
        document.getElementById('endInput').value = endOfDay.toISOString().slice(0,16);
    });
    </script>
</body>
</html>
